# 캐시

캐시된 데이터는 가까운 곳에서 빨리 불러오자

- 왜 그래야하나
    - 네트워크 비용 줄이기 
        - 불필요한 데이터 전송 
        - 중복 트래픽 주고 받지 않아도 됨
    - 네트워크 병목 줄이기 
        - LAN에 더 넓은 대역폭 제공함
        - 용량 큰 문서일 수록 대역폭 좁으면 지연 심함
    - 원 서버 부하 줄이기 
        - 원 서버에 요청 안가므로
        - 특히 갑작스런 요청 쇄도 상황
    - 지연 줄이기 - 가까이서 불러오므로
        - 빛의 속도로 인한 지연, 즉 거리와 비례
        - 동시에 몇개의 커넥션을 열고 keep-alive에 유지하냐에 따라 반비례


## 캐시 hit, miss, revalidation
#### 클라이언트 - 캐시
- hit: 캐시된 사본제공
- miss: 서버에서 가져온 데이터 제공


#### 캐시 - 서버
- 캐시 신선도 검사 = HTTP 재검사
- If-Modified-Since헤더를 GET요청에 추가하면 캐시에서 재검사 위한 작은 요청을 서버로 보냄
- 대부분의 캐시는 사본이 충분히 오래된 경우에만 재검사 함
- 재검사 hit: 304,캐시된 사본에 신선도 다시 표기하여 제공
- 재검사 miss: 200, 서버에서 가져온 데이터 제공
- deleted: 404, 캐시된 사본 삭제

### 적중률
- 캐시가 요청 처리하는 비율
- 최대한 웹 트랜잭션을 외부로 내보내지 말자
- 개선 시 전체 대기시간(지연) 줄어듬
- 40%정도면 웹 캐시로 괜찮

### 바이트 적중률
- 캐시로 제공된 모든 바이트의 비율
- 덜 접근되더라도 용량 큰 객체를 캐시하자
- 최대한 바이트를 인터넷으로 내보내지 말자
- 개선 시 대역폭 절약

### 응답이 캐시에서 왔는지 확인하는 법
- 응답 Date헤더를 현재시각과 비교하여 더 오래되었으면 캐시된 것
- 응답의 Age헤더를 이용
- 일부 상용 프락시 캐시는 via헤더에 캐시에 대한 추가 정보 붙임

## 캐시 토폴로지(연결망)

### 개인 전용 캐시
- 작고 저렴
- 웹브라우저는 개인 전용 캐시 내장하고 있음
- 개인용 컴퓨터의 디스크와 메모리에 자주 쓰는 문서 캐시 해놓음

### 공용 프락시 캐시
- =캐시 프락시 서버 = 프락시 캐시
- 여러 사용자를 대상으로 하므로 네트워크 트래픽 더 크게 줄일수 있음
- 브라우저가 프락시 캐시 사용하도록 설정하는 방법
    - 수동 프락시 지정
    - 프락시 자동설정 파일 설정
    - 인터셉트 프락시 사용하여 HTTP요청이 캐시 통하도록 강제

### 프락시 캐시 계층 만들기
- 클라이언트 주위에는 작고 저렴한 캐시
- 계층 상단에는 크고 강력한 캐시
- 프락시 연쇄가 길어질수록 중간 프락시들은 성능저하
- 두 세개의 프락시만 거치도록 제한함. 새로운 고성능 프락시 서버들은 연쇄길이가 문제되지 않기를 원함(..?현상황 궁금)

### 계층보다 복잡한 캐시망 만들기
- 동적인 캐시들
    - url보고 부모 캐시로 갈지 원서버로 갈지 선택
    - url보고 어떤 부모로 갈지 선택
    - 다른 캐시들이 자신의 콘텐츠에 부분적으로 접근하도록 허용

- 형제 캐시
    - 직접적으로 연결된 부모계층이 아니더라도 광역통신망을 통해 피어링
    - HTTP는 형제 캐시 지원하지 않음
    - 인터넷 캐시 프로토콜 ICP
    - 하이퍼텍스트 캐시 프로토콜 HTCP
    
## 캐시처리 단계
1. 요청 받기
    - 네트워크 커넥션의 활동 감지, 데이터 읽기
    - 고성능 캐시는 여러개의 커넥션에서 동시에 데이터 읽고 메시지 전체 받기 전에 트랜잭션 처리 시작

2. 파싱
    - 요청 메시지를 파싱하여 헤더 부분을 조작 쉬운 자료구조로변화
    - 헤더 부분의 정규화
    - 절대, 상대 url 정규화

3. 검색
    - url에 해당하는 사본있는지 검사, 이때 빠른 알고리즘 사용(..?)
    - hit이면 캐시된 객체 응답
        - 캐시 관련 메타 데이터 포함, 어떤 캐시는 원 클라인트 요청 헤더들 사본도 포함

4. 신선도 검사
    - 캐시 제품이 지원하는 많은 설정 옵션있음
    - 비 HTTP 의 신선도 표준과 상호작용도 필요
    - 따라서 복잡

5. 응답 생성
    - 캐시는 클라이언트에 맞게 원서버의 헤더를 조정해야함 (ex http 버전다르면 번역)
    - 캐시 신선도 정보(cache-control, age, expires 헤더) 삽입
    - 재검사해야하는데 원서버가 다운된 경우 에러 응답해야함
    
6. 전송
    - 클라이언트와 커넥션 유지하고 있어야함
    - 고성능 캐시는 로컬 저잗장치와 네트워크 i/o 버퍼 사이의 콘텐츠 복사 피하여 효율 높임(..?)

7. 로깅
    - hit, miss 횟수 등 통계 위해 로그 파일에 데이터 추가
    - 많이 쓰이는 로그파일 포맷은 [스퀴드 로그 포맷](https://wiki.squid-cache.org/Features/LogFormat)


## 신선도 검사 더 알아보기

### 유효기간
- Cache-Control, Expires 헤더: 각 문서에 유효기간 붙이기
```
Cache-Control: max-age=400000
Expires: date
```
- 이 시간 이후로는 문서 만료되었으므로 서버 재검사 필요
- 재검사 hit이면 캐시는 새 만료일 포함한 헤더들만 가져와서 캐시 헤더만 갱신

### 조건부 헤더
- 조건부 헤더가 참인 경우에만 웹서버에서 객체 반환
```
If-Modified-Since: date
If-None-Match: tags
If-Unmodified-Since:
If-Range:
If-Match:
```

#### If-Modified-Since(IMS)
- 특정 날짜 이후로 변경된 경우에만 본문 응답해줘라
- 변경 안되었으면 304+갱신필요한 헤더만 보냄. 서버->클라이언트
- 응답 헤더의 Last-Modified와 함께 동작
    - 캐시가 재검사 요청할 때, If-Modified-Since의 값을 Last-Modified값으로 설정함

#### If-None-Match
- If-Modified-Since: Last-Modified 검사가 유효하지 않은 상황
    - 변화했지만 사실 같은 내용..
    - 너무 사소한 변화
    - 최근 변경일시를 신뢰할 수 없음
    - 1초보다 작은 간격으로 갱신되는 문서
- 문서의 엔터티 태그(ETag헤더)를 이용하여 해당 태그가 변경되었다면 본문 응답
- 약한 검사기(엔터티에 유의미한 변경이 있을 때만)/ 강한 검사기(엔터티에 변경이 있다면 항상)
- 강한 검사기: 두 리소스 표현의 내용이 바이트 단위로 동일하고 다른 모든 엔티티 필드(ex. content-lang)도 변경되지 않았음을 보장

#### 두 헤더의 조합
- HTTP1.1 원 서버는 엔터티 태그 검사가능하도록 구현하는 것 권장
- 두 조건부 헤더 둘다 사용하는 경우 둘다 만족해야 304 응답

## 캐시 제어 (서버)
- 서버는 문서가 얼마나 오래 캐시되게 할것인지 응답헤더에 설정할 수 있음

### no-cache, no-store
```
Cache-Control: no-cache
Cache-Control: no-store
```
- no-store 캐시가 사본을 만들지 못하게 강제, 따라서 캐시는 응답 전달후 객체 삭제함
- no-cache 캐시가 사본을 저장할 수 있지만 항상 재검사해야함
- HTTP/1.0은 Pragma: no-cache만 이해 가능

### Max-Age
- max age를 0으로 설정하여 항상 재검사
- s-maxage는 공용 캐시에만 적용

### Expires
- 절대 만료 날짜
- 이제 사용하지 말기를 권장 
- 서버시간이 항상 정확하지 않기때문
- Expires:0은 문법위반임

### Must-Revalidate
- 어떤 설정으로 캐시가 만료된 객체를 그냥 제공할수도 있는데, 이 헤더를 붙이면 금지됨
- 이 헤더로 인해 신선도 검사 시도중 서버 사용할 수 없는 상태라면 504응답해야함

### 휴리스틱
- 응답헤더에 캐시설정 아무것도 없을 때
- 알고리즘으로 얻은 나이값이 24시간보다 크면 경고헤더가 추가되어야함(사실상 따르는 브라우저가 없음)
- LM 인자 알고리즘 - 마지막 변경이 예전일수록 잘 안바뀌는 문서이므로 만료시간 오래주자
- 휴리스틱 유지기간에 상한설정하여 유지기간 너무 커지는 것 막음(보통 1주일)

## 캐시 제어 (클라이언트)
- 브라우저의 리프레시, 리로드: Cache-control 요청헤더를 추가하여 GET요청 발생시킴 (구체적인 설정은 각 브라우저, 캐시 설정에 달림)

### max-stale
- 캐싱 규칙 느슨하게 함
- 신선하지 않아도 캐시에서 사본 받아옴
- 매개변수를 지정하면 매개변수 만큼 만료시간 지나도 받아옴
### min-fresh
- 캐싱 규칙 엄격하게 함
- 지금부터 매개변수 시간 이후까지도 신선한 문서만 받아옴
### max-age
- 매개변수 시간보다 오래 된 캐시 문서는 받아오지 않음
### no-cache
- 캐시된 문서는 무조건 재검사해야 받아옴
### no-store
- 캐시 저장소에서 문서를 최대한 빨리 삭제해야함 (민감 정보 포함)
### only-if-cached
- 캐시의 사본만을 받아옴

## 문서의 나이계산 알고리즘
- 문서의나이 < 신선도 수명
- 문서 나이: 서버가 보낸 혹은 마지막으로 재검사 한 후 지금까지 문서의 보존 시간
    - Date(원서버에서 나간 시간), Age헤더로 유추
    - 모든 서버의 시간이 정확한것은 아니므로 Date로 유추하는 것은 **겉보기 나이**
    - 서버의 부정확한 시간으로 인한 문제 = 클록 스큐
    - 이를 보완하기 위한 **점층적 나이** 계산은 Age헤더를 활용
    - 문서가 프락시나 캐시 통과 할때마다 Age헤더에 나이 누적
    - HTTP 1.1이 아닌 경우 헤더 인식 못하므로 100% 정확한것 아님
    - 점층적 나이와 겉보기 나이 중 큰 것이 선택 됨
    - +네트워크 지연 추정값 (캐시에서 응답 받은시간 - 응답 요청 시간)
    - = 문서가 캐시에 도착했을때의 나이 + 현재 캐시에서의 체류시간
    - = 문서 나이
- 신선도 수명: 서버 만료 정보, 클라이언트 신선도 요구사항 조합하여 판별
    - 서버와 클라이언트의 제약조건에 의지
    - 서버의 신선도 한계 계산
        - max_age > expires - date > date - last_modified > default
    - 클라이언트 신선도 한계 계신
        - max_stale > min_fresh > max_age
## cf. 광고회사와 캐시
- 캐시적중되면 서버에 접근 기록 남지 않아 얼마나 많은 사용자가 광고 보았는지 기록이 어려움
- 캐시 무력화(매번 새 url로 광고 제공한다던지)는 좋지 않은 방법
- 캐시 로그를 원서버에 보내는 방법쪽으로 발전하는 중

# 15장 엔터티와 인코딩

## 메시지는 컨테이너, 엔터티는 화물

HTTP 메시지를 운송 시스템의 컨테이너라 한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.
HTTP/1.1은 다음과 같이 10가지 주요 엔터티 헤더 필드를 정의하였다.

- Content-Type 엔터티에 의해 전달된 객체의 종류
- Content-Length 전달되는 메시지의 길이나 크기
- Content-Language 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding 객체 데이터에 대해 행해진 압축과 같은 변형
- Content-Location 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range 부분 엔터티라면 전체에서 어느 부분에 해당하는지 정의
- Content-MD5 엔터티 본문의 컨텐츠에 대한 체크섬
- Last-Modified 서버에서 이 컨텐츠가 생성, 수정된 날
- Expires 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- Allow 이 리소스에 대해 어떤 요청 메서드가 허용되는지
- ETag 이 인스턴스에 대한 고유한 검사기
- Cache-Control 어떻게 이 문서가 캐시될 수 있는지에 대한 지사자
- Etag, Cache-Control은 엄밀히 말해 엔터티 헤더로 정의되지 않았다.

### 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 다른 정보들은 모두 헤더에 담겨 있다. 따라서 엔터티 헤더는 그 데이터의 의미를 설명할 필요가 있다.

엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다. 16진수 값들은 텍스트와 이미지 엔터티의 정확한 내용을 알려준다.

## Content-Length: 엔터티의 길이

Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다. 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.

Content-Length 헤더는 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다. 서버 충돌로 인한 메시지 잘림 검출과 지속 커넥션을 공유하는 메시지를 분할하고자 할 때 필요하기 때문이다.

### 잘림 검출

오래된 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다. 그러나 Content-Length가 없다면 커넥션이 정상적으로 닫힌 것인지 구분하지 못한다.

메시지 잘림은 캐싱 프록시 서버에서 특히 취약하다. 만약 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인삭하지 못했다면, 캐시는 결함이 있는 컨텐츠를 저장하고 계속해서 제공하게 될 것이다.

이러한 일을 방지하고자 캐싱 프록시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 캐시하지 않는다.

### 잘못된 Content-Length

Content-Length가 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있다. HTTP/1.1에서는 사용자 에이전트가 잘못된 길이를 받고 이를 인지했을 때, 사용자에게 알려주게 되었다.

### Content-Length와 지속커넥션

Content-Length는 지속 커넥션을 위해 필수다. 이는 클라이언트에게 메시지 하나가 어디서 끝나고, 다음 시작은 어디인지 알려준다.

커넥션은 지속적이기에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하다. 따라서 HTTP 애플리케이션은 엔터티 본문의 길이와 끝을 인식하고자 Content-Length 헤더를 활용한다.

청크 인코딩을 사용하는 경우는 예외이다. 청크 인코딩은 데이터를 특정 크기를 갖는 청크들로 쪼개어 보내며, Content-Legnth 헤더를 필요로 하지 않는다.

#### 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔터티 본문을 인코딩할 수 있게 해준다.

만약 본문의 컨텐츠가 인코딩되어 있다면, Content-Length 헤더는 원본이 아닌 인코딩된 본문을 바이트 단위로 정의한다.

HTTP/1.1 명세에서 그 어떤 헤더도 인코딩 전 원본의 길이를 보내고자 사용되지 않는다. 클라이언트가 수행한 디코딩 과정의 검증을 어렵게 하기 때문이다.

Content-MD5 헤더도 인코딩된 문서의 MD5를 담는다. 그러나 자주 사용되지 않는다.

### 엔터티 본문의 길이 판별을 위한 규칙

다음은 엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 규칙들이다.

1. 본문을 갖지 못하는 타입의 HTTP 메시지에서는, Content-Length 헤더가 무시된다. 만약 존재하더라도 단순히 부가정보에 불과하며, 실제 본문의 길이를 서술하지 않는다.
   대표적인 예는 HEAD 응답이다. 1XX, 204, 304 응답 또한 본문을 갖지 않는다.

2. 메시지가 Transfer-Encoding 헤더를 포함하고 있고 커넥션이 닫혀 먼저 끝나지 않는다면, 메시지는 0바이트 청크라 불리는 패턴으로 끝나야 한다. 만약 이 헤더가 포함된 메시지를 받았다면 Content-Length 헤더는 무시되어야 한다.

3. 메시지가 multipart/byteranges 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 메세지는 각자가 스스로의 크기를 정의한다. 따라서 수신자가 이를 해석할 수 있다는 사실을 송신자가 알기 전까지는 이 미디어 타입을 절대 보내서는 안된다.
   해당 규칙은 HTTP/1.1 명세에서 이 규칙은 삭제되었다.

4. 위의 규칙에 해당하지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다. 실질적으로 커넥션은 오직 서버만이 닫을 수 있다. 클라이언트가 커넥션을 닫아버리면 서버가 응답을 돌려줄 방법이 없기 때문이다.
   클라이언트는 출력 채널만을 닫는 절반 끊기를 할 수도 있지만, 모든 서버에 설계된 것이 아니며 공식 명세에도 관련된 내용은 없다.

5. HTTP/1.0 애플리케이션과의 호환을 위해, 본문을 갖는 HTTP/1.1 요청은 Content-Length 헤더를 포함해야 한다. 없는 경우에 메시지의 길이를 판별할 수 없다면 400 Bad Request를, 유효한 Content-Length 헤더를 요구하고 싶다면 411 Length Required 응답을 보내도록 권고된다.

   

## 미디어 타입과 차셋(Charset)

Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다. MIME 타입은 전달되는 데이터 메체의 기저 형식의 표준화된 이름이다. 클라이언트 애플리케이션은 컨텐츠를 해독하고 처리하고자 이를 이용한다.

MIME 타입은 text/html과 같이, 주 미디어 타입과 이를 구체적으로 기술하는 부 타입으로 구성된다.

Content-Type 헤더는 엔터티가 컨텐츠 인코딩을 거친 후에도 여전히 엔터티 본문의 미디어 타입을 명시한다는 점에서 중요하다.

### 텍스트 매체를 위한 문자 인코딩

Content-Type 헤더는 내용의 타입을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다. 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 charset 매개변수가 대표적인 예이다.

    Content-Type: text/html; charset=iso-8859-4

### 멀티파트 미디어 타입

MIME 멀티파트 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다. 각 구성요소는 자신에 대해 서술하는 헤더를 포함한다. 이들은 서로 이어져 있으며, 문자열 하나로 경계가 식별된다.

HTTP는 멀티파트 본문도 지원한다. 그러나 폼(form)을 채워 제출할 때와 문서의 일부분을 보내는 범위 응답을 할 때에만 사용된다.

### 멀티파트 폼 제출

HTTP 폼(form)을 채워 제출하면, 가변 길이 텍스트 필드와 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.

예를 들어, 사용자가 텍스트와 사진을 폼에 채워 보낸다고 하자. 이는 Content-Type: multipart/form-data나 Content-Type: multipart/mixed 헤더에 함께 실어 보내질 것이다.

    Content-Type: multipart/form-data; boundary=[abcdefg]

여기서 boundary 매개변수는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

### 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있다. 이러한 응답은 Content-Type: multipart/byteranges 헤더와 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

### 콘텐츠 인코딩

HTTP 애플리케이션은 종종 컨텐츠를 보내기 전에 인코딩을 하려고 한다. 느린 속도를 보완하고자 큰 문서를 압축하거나, 허가받지 않은 자가 접근할 수 없도록 컨텐츠를 암호화할 수도 있다.

이러한 종류의 인코딩은 발송하는 쪽에서 컨텐츠에 적용한다. 컨텐츠 인코딩이 끝난 데이터는 엔터티 본문에 담아 수신자에게 보내진다.

콘텐츠 인코딩 과정
웹 서버가 원본 Content-Type과 Cotnet-Length 헤더를 수반한 원본 응답 메시지를 생성한다.

컨텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 만약 압축되었다면, Content-Type은 같지만 Content-Length는 다르다. 또한, Content-Encoding 헤더를 메시지에 추가하여 디코딩할 수 있도록 한다.

수신 측 애플리케이션은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

컨텐츠 인코딩 유형
HTTP는 몇 가지 표준 컨텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.

인코딩은 각 컨텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다.

Content-Encoding 헤더는 표준화된 토큰 값을 이용해서 인코딩에 사용된 알고리즘들을 기술한다. 다음은 자주 쓰이는 컨텐츠 인코딩 토큰들이다.

gzip 엔터티에 GNU zip 인코딩이 적용되었음을 의미한다.
compress 엔터티에 유닉스 파일 압축 프로그램인 compress가 실행되었음을 의미한다.
deflate 엔터티가 zlib 포맷으로 압축되었음을 의미한다.
identity 엔터티에 어떤 인코딩도 수행되지 않았음을 의미한다. Content-Encoding 헤더가 없을 때의 기본값이다.
gzip, compress, deflate 인코딩은 무손실 압축 알고리즘이다. 이 중 gzip이 가장 효율적이고 널리 쓰인다.

Accept-Encoding 헤더
서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해 전송한다.

만약 HTTP 요청에 해당 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있는 것으로 간주한다.

Accept-Encoding: *을 전달한 경우와 같다.

아래 예시에서 Q(quailty) 매개변수는 선호도를 나타내며, 0.0부터 1.0 사이의 값을 지정할 수 있다. 또한, identity 인코딩 토큰은 Accept-Encoding 헤더에서만 사용할 수 있다.

    Accept-Encoding: gzip; q=1.0, identity; q=0.5, *; q=0

## 전송 인코딩과 청크 인코딩

전송 인코딩도 엔터티 본문에 적용되는 변환이지만, 구조적인 이유 때문에 적용되는 것이며 컨텐츠의 포맷과는 독립적이다.

컨텐츠 인코딩은 엔터티 본문만을 인코딩한다. 전송 인코딩은 메시지 전체에 적용된다.

### 안전한 전송

전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 안전한 전송을 위해 존재했다.

HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유는 몇 가지 밖에 없다. 그 중 두 가지는 다음과 같다.

몇몇 게이트웨이 애플리케이션과 컨텐츠 인코더는 컨텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다. 이 서버들은 대개 그 사이즈를 알기 전에, 데이터의 끝을 알리는 꼬릿말을 포함시켜 전송 인코딩으로 데이터를 보내려고 한다.

공용 전송 네트워크로 메시지 컨텐츠로 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 바꾸는 방법도 있다. 그러나 SSL과 같은 전송 계층 보안 방식이 있기에 전송 인코딩 보안은 잘 쓰이지 않는다.

### Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위한 헤더는 단 두 개뿐이다.

Transfer-Encoding 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
TE 어떤 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.
모든 전송 인코딩 값은 대소문자가 구별된다. HTTP/1.1은 Transfer-Encoding과 TE 헤더 필드에 전송 인코딩 값을 사용한다. 최신 HTTP 명세는 청크 인코딩만을 정의한다.

TE 헤더는 Accept-Encoding 헤더와 마찬가지로 Q 값을 가질 수 있다. 그러나 HTTP/1.1 명세는 청크 인코딩의 Q 값이 0.0인 것을 금한다.

### 청크 인코딩

청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 청크를 순차적으로 보낸다. 이를 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.

본문이 동적으로 생성되고, 서버는 일부를 버퍼에 담아 크기와 함께 전송한다. 본문 전체를 모두 보낼 때까지 이를 반복한다.

청크 인코딩이 전송 인코딩의 한 형태이며, 본문이 아닌 메시지의 속성임에 주목해야 한다. 멀티파트 인코딩은 본문의 속성이며 청크 인코딩과는 완전히 분리되어 있다.

청크와 지속 커넥션
지속 커넥션에서 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 한다. 그러나 컨텐츠가 서버에서 동적으로 생성되는 경우에는 본문의 길이를 알아내는 것이 불가능하다.

청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이를 해결해준다. 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.

청크 인코딩은 HTTP 응답 헤더 블록으로 시작하고, 이어서 청크의 스트림이 온다. 각 청크는 길이 값과 각 청크에 대한 데이터를 담고 있다.

길이 값은 16진수 형식으로 되어 있고 데이터와 CRLF로 분리된다. 데이터는 바이트 단위로 측정되고 청크 끝의 CRLF 문자열뿐 아니라 길이 값과 데이터 사이의 CRLF 문자열도 길이에 포함하지 않는다.

마지막 청크는 본문의 끝을 의미하기 위해 길이가 0이다.

    // message header
    HTTP/1.1 200 OK<CR><LF>
    Content-type: text/plain<CR><LF>
    Transfer-encoding: chunked<CR><LF>
    Trailer: Content-MD5<CR><LF>
    <CR><LF>
    
    // chunk #1
    27<CR><LF>
    We hold these truths to be self-evident<CR><LF>
    
    ...
    
    // last chunk
    0<CR><LF>
    
    // trailer
    Content-MD5: gjpei54p25tjisgj3p4utjgrj53<CR><LF>    

클라이언트는 또한 청크 인코딩된 데이터를 서버로 전송한다. 서버가 청크 인코딩을 지원하는지 모르기에, 청크 요청이 411 Length Required 응답으로 거절당하는 것에 대비해야 한다.

서버는 클라이언트에게 TE 헤더를 포함시켜 보내지 않는다.

청크 인코딩된 메시지의 트레일러
다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.

클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
트레일러가 응답을 만든 서버에 의해 추가되었으며, 해당 트레일러의 컨텐츠는 선택적인 메타 데이터라 클라이언트가 무시하고 버려도 되는 경우
트레일러는 본문의 컨텐츠가 먼저 생성되야 한다는 등의 이유로, 메시지 시작 시점에서는 알 수 없는 추가적인 헤더 필드를 담을 수 있다.

마지막 청크 다음에 Trailer 헤더에 나열했던 헤더들이 온다. Transfer-Encoding, Trailer, Content-Length를 제외한 모든 헤더를 보낼 수 있다.

### 콘텐츠와 전송 인코딩의 조합

컨텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다. 송신자는 컨텐츠 인코딩을 사용해서 데이터를 압축하고, 이를 청크 인코딩하여 전송한다.

수신자가 본문을 재구축하는 절차는 반대이다. 청크 데이터를 디코딩한 후, 이를 컨텐츠 디코딩하여 본문을 얻는다.

### 전송 인코딩 규칙

전송 인코딩이 메시지 본문에 적용될 때 몇 가지 규칙이 반드시 적용되야 한다.

전송 인코딩의 집합은 반드시 chunked를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.

청크 전송 인코딩이 사용되었다면, 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.

청크 전송 인코디은 반드시 메시지 본문에 한 번 이상 적용되야 한다.

이 규칙은 수신자가 메시지의 전송 길이를 알아낼 수 있게 해준다. 전송 인코딩은 HTTP/1.1에서 소개된 기능이다.

따라서 서버는 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 주의해야 한다. 반대로 서버가 이해할 수 없는 전송 인코딩된 메시지를 받았다면, 서버는 501 Unimplemented 상태 코드로 응답해야한다.

마지막으로 HTTP/1.1 애플리케이션은 청크 인코딩만은 반드시 지원해야 한다.

## 시간에 따라 바뀌는 인스턴스

웹 객체는 동적이다. 똑같은 요청이라도 시간에 따라 다른 버전의 객체를 가리킬 수 있다.

HTTP 프로토콜은 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이를 인스턴스 조작(instance manipulation) 이라 한다. 대표적인 두 가지가 범위 요청과 델타 인코딩이다.

두 가지 모두, 클라이언트가 자신의 리소스 사본이 서버의 것과 일치하는지 판단하고 상황에 따라 새 인스턴스를 요청할 수 있도록 해준다.

## 검사기와 신선도

### 신선도

서버는 클라이언트에게 컨텐츠를 캐시할 기간과 신선도의 대한 정보를 줄 것이다. 서버는 Expires나 Cache-Controll 헤더를 통해 이러한 정보를 제공할 수 있다.

Expires 헤더는 문서가 만료되어 더 이상 신선하지 않게 되는 날짜를 명시한다. 이를 제대로 사용하기 위해서는 시계를 반드시 동기화 시켜야 하지만, 이것이 쉽지는 않다.

    Expires: Sun Mar 18 23:59:59 GMT 2001

Cache-Control 헤더는 최대 수명을 문서가 서버를 떠난 후로부터의 총시간을 초 단위로 정한다. 수명은 시계 동기화에 의존하지 않는 상대 시간으로 더 정확한 결과를 말해준다.

### 조건부 요청과 검사기

캐시의 사본이 요청되었을 때 신선하지 않다면, 캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요가 있다.

동일한 요청으로 네트워크 대역폭을 낭비하고 서버에 부하를 주는 것을 막기 위해서, HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라는 방법을 제공한다.

If-로 시작하는 조건부 헤더는 조건이 참일 경우에만 수행된다. 만약 조건이 거짓이라면, 서버는 에러 코드를 반환한다.

HTTP는 검사기를 약한 검사기와 강한 검사기 두 가지로 분류한다. 약한 검사기는 리소스의 인스턴스를 고유하게 식별하지 못하는 경우도 있다. 강한 검사기는 언제나 고유하게 식별한다.

약한 검사기의 예로 객체의 바이트 단위 크기가 있다. 리소스 컨텐츠에 대한 암호 체크섬은 강한 검사기다.

최종 변경 시각은 약한 검사기로 간주되는데 정확도가 최대 1초에 불과하기 때문이다. 반면 ETag 헤더는 강한 검사기이다. 서버는 매 변경마다 구분되는 값을 넣어두기 때문이다.

## 범위 요청

HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다. 예를 들어 클라이언트가 다음과 같은 범위 요청을 했다고 하자.

    GET /bigfile.html HTTP/1.1
    Host: www.example.com
    Range: bytes=4000-
    User-Agent: Mozilla/4.61 [en] (WinNT; I)
    ...

클라이언트는 처음 4,000바이트 이후의 부분을 요청하고 있다. 이 예시에서 클라이언트가 하나의 요청으로 여러 범위를 요청했을 때, 응답은 멀티파트 본문, Content-Type: multipart/byteranges 헤더와 함께 하나의 엔터티로 돌아온다.

서버는 클라이언트에게 범위를 받아들일 수 있는지를 Accept-Range 헤더를 응답에 포함시키는 방법으로 알려줄 수 있다. 이 헤더의 값은 측정의 단위이며, 주로 바이트이다.

범위 요청은 객체의 특정 인스턴스를 클라이언트와 서버 사이에서 교환하는 인스턴스 조작이라는 것에 주의해야한다. 즉, 범위 요청은 클라이언트와 서버가 같은 버전의 문서를 갖고 있을 때만 의미가 있음을 말해준다.

## 델타 인코딩

웹 페이지의 각기 다른 버전들은 그 페이지에 대한 각기 다른 인스턴스다.

클라이언트에게 최신 인스턴스를 제공할 때, 전체를 보내는 대신 사본의 변경 부분만을 서버가 보낸다면 클라이언트는 더 빠른 응답을 얻을 수 있을 것이다.

델타 인코딩은 이처럼 변경된 부분만 통신하여 전송량을 최적화하는 HTTP 프로토콜의 확장이다. 델타 인코딩 역시 인스턴스 조작이다. 클라이언트와 서버가 특정 객체 인스턴스들의 정보 교환에 의존하기 때문이다.

클라이언트는 페이지의 어떤 버전을 갖고 있는지 서버에게 말해주어야 하는데, 이는 클라이언트가 페이지의 최신 버전에 대한 델타(변경된 부분)를 받아들일 의사가 있음을 의미한다.

그리고 클라이언트는 자신이 갖고 있는 현재 버전에 델타를 적용하기 위해 어떤 알고리즘을 알고 있는지도 말해주어야 한다.

이에 서버는 클라이언트의 버전을 갖고 있는지, 그리고 어떻게 델타를 계산할 것인지에 대해 체크해야 한다.

클라이언트의 객체와 최신 버전 객체 간의 델타를 계산해주는 여러 알고리즘이 존재한다.

이후 델타를 계산하여 클라이언트에게 보내준다. 그리고 서버가 델타를 보내고 있음을 클라이언트에게 알려주고, 페이지의 최신 버전에 대한 새 식별자를 명시해야 한다.

클라이언트는 자신이 갖고 있던 버전에 대한 식별자인 ETag 헤더 값을 If-None-Match 헤더에 담아 조건부 요청을 한다. 동시에 클라이언트는 A-IM 헤더를 보내서 페이지에 대한 델타를 받아들일 수 있음을 알려줄 수도 있다.

A-IM은 Accept-Instance-Manipulation의 약자이다.

서버는 클라이언트에게 요청 객체 자체가 아닌 인스턴스 조작을 보내고 있음을 말해주는 226 IM Used 상태 코드, 델타를 계산하는데 사용한 알고리즘을 명시한 IM 헤더, 새로운 ETag, 그리고 델타를 계산하는데 기반이 된 문서의 ETag를 지정한 Delta-Base 헤더를 되돌려준다.

인스턴스 조작, 델타 생성기 그리고 델타 적용기
클라이언트는 A-IM 헤더에 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있다. 서버는 IM 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있다.

다음은 IANA에 등록된 인스턴스 조작의 종류들이다.

vcdiff vcdiff 알고리즘을 이용한 델타
diffe 유닉스 diff-e 명령을 이용한 델타
gdiff gdiff 알고리즘을 이용한 델타
gzip gzip 알고리즘을 이용한 압축
deflate deflate 알고리즘을 이용한 압축
range 현재 응답이 부분 컨텐츠임을 말해주기 위해 서버 응답에서 사용된다.
identit 클라이언트가 identity 인스턴스 조작을 받아들일 의사를 말해주기 위해 사용된다.
델타 생성기는 A-IM 헤더에 지정된 알고리즘를 이용하여 기저 문서와 최신 인스턴스 사이의 델타를 계산한다. 자세한 내용은 공식 명세인 RFC 3229를 참고하자.

델타 인코딩의 A-IM, IM 헤더는 복수 개의 인스턴스 조작들을 지정할 수 있다. 또한 문서는 여러 번의 인스턴스 조작을 거쳐 클라이언트에게 반환될 수 있다.

예로 vcdiff 알고리즘으로 생성된 델타는 gzip 알고리즘으로 압축될 수 있다.

하지만 델타 인코딩은 구현하기 까다롭다. 이를 지원하는 서버는 자신이 제공하는 페이지가 변경되는 매 순간의 사본을 모두 유지해야 하기 때문이다.

결국, 서버는 반드시 클라이언트가 가지고 있던 이전 버전의 사본들을 유지해고자 저장 공간을 늘려야한다. 이는 전송량 감소로 얻은 이득을 무의미하게 한다.
